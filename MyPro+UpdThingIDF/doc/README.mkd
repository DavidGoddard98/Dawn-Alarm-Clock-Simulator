My documentation for COM3505 assessment 1 (MyPro+UpdThing)
===
### Pro+UpdThing

In summary, the existing system connects the ESP-32 to a network, and then checks to see if it has the latest version of the firmware by reference to a gitlab repo. If it doesn't, it performs an Over-the-air update by downloading the latest firmware from the repo and writes this to the ESP-32. 


### Provisioning

### What is provisioning?

Devices that have limited hardware can connect to a Wi-Fi network by a process called provisioning. They can either be set up in station mode which enables them to connect to a previously saved AP (access point), or in AP mode - which is achieved in most cases by using another external device (with a browser) that allows a user to supply the network information via the newly created web server by the IoT device. 

### The implementation in the existing system

1. On startup, the ESP sets up in station mode (allows to connect itself to a Wi-Fi network) and attempts to connect to a previously saved AP.

2. If unsuccessful, it moves into Access Point mode to create its own network and starts a DNS and WebServer for other devices to connect to it.

3. Connecting to the newly created AP via any Wi-Fi enabled device with a browser will prompt the user to enter the apKey (if any) of the AP.

4. Once successfully connected to the AP, a pop-up will be displayed showing the configuration portal, or attempting to visit any domain will redirect to the configuration portal due to the Captive Portal and DNS server.

5. After selecting and entering the password for one of the scanned APs, the ESP will attempt to connect – if successful, the application is now in control with an established Wi-Fi connection. If not, reconnect to the AP and reconfigure.

##### Diagram and method descriptions

![](_Basic_Flowchart.png)

>**joinmeManageWiFi(const char *apSSID*, const char *apKey*)** → returns true if connection is established

>**apSSID** → the network name we wish to connect to

>**apKey** → the password associated to the network

>**WifiManagerParameter** → Create custom parameters that can be added to the WiFiManager setup web page

>**addParameter** → adds a custom parameter, returns false on failure

>**setSaveParamsCallback** → called when parameters have been set and connection was successful

>**setConnectTimeout** → how long to try to connect before continuing

>**setConfigPortalTimeout** → auto close config portal after n seconds

>**autoConnect** → auto connect to saved wifi, or custom, and start config portal on failures

>**setSaveConfigCallback** → set a save config callback after closing configportal

>**startConfigPortal** → config portal start

>**autoConnect(apSSID, apKey)** → start access point












### Security 

Despite this, there are some aspects of the system that are not secure. For instance the ESPs mac address is used as the APs SSID. The vulnerability of this is that if an attacker is on the same network as you they could intercept your traffic by posing as the networks router. It would therefore be a better idea to use store the SSID as a different term.

### Over-The-Air Implementation

### What is OTA? 

The very nature of the Internet of Things makes OTA updating a necessary requirement to ensure firmware is kept up to date. Indeed, millions of devices make-up the IOT and updating these all individually in person is neither a cost-effective nor a practical way to install the latest firmware. This is why OTA processes are so important: it enables manufacturers who incorporate the microcontroller into their device the ability to update the devices over the internet. This very fact describes the importance of provisioning - it enables OTA updates to take place. 

### OTA Implementation 

To upload the latest version of the firmware to Gitlab, so it is ready to be fetched by the ESP, the user writes ‘make push-firmware’ in the terminal. This compiles the firmware and creates a version.txt file which holds the value of the compiled firmwares version number. It then pushes these both to Gitlab in the firmware directory.
 
Once the ESP has established a connection, it is ready to perform an OTA update. It begins by calling a function called joinmeOTAUpdate, which in turn calls another function called joinMeCloudGet. This creates a get request to retrieve an integer value containing the latest version number of the firmware available on Gitlab. It then cross references this with the version of the firmware currently on the ESP. If it is outdated it means the firmware needs to be upgraded. The system therefore makes a final call to joinmeCloudGet which creates another get request to retrieve the (firmwareVersion).bin file from Gitlab. If this is retrieved successfully, it writes this to the ESP and restarts it. The ESP now has the latest version of the firmware successfully installed.

### Security

On the whole, the existing system is fairly secure. The main reason for this is because the firmware updates are retrieved from Gitlab using a secure transfer protocol known as HTTPS. This is secure for two reasons. One, it ensures the validity of the website you are connected with by checking the validity of the certificate from the server. In the context of the existing system, this means that the firmware will always be downloaded from the legitimate repository on Gitlab preventing the risk of an attacker transferring malicious code to the ESP32. 

Secondly, HTTPS encrypts all communications between the client and the server. Again, in this context this removes the potential for an attacker to eavesdrop on the data transferred which could contain sensitive information such as network credentials. 


    
### How efficient is the implementation? 

One efficiency of the system is the fact that it only carries out an OTA update when the ESP is started. This means that it is not constantly searching for updates while it is running, resulting in a lower power consumption. However, although this might improve efficiency, calli 


### How might it be improved? 

As stated above, the system only checks for updates when the ESP is restarted and although this improves efficiency it sort of defeats the point of the OTA implementation. This is because with the current configuration of the system, someone would have to restart the device manually for any updated firmware to be downloaded. Usually, in real world applications the ESP would be embedded within a system and therefore restarting the device whenever an update is required is unrealistic. To overcome this issue, the ESP could check for updates periodically while it is running. This could be achieved by regularly calling the joinmeOTAUpdate method within the loop function in the main file. In our code we made this improvement, calling the OTA function every 1000 iterations of the loop function in the main file. 

### Securing the ESP through sense of touch

With ESPs a major cause for concern is its physical security due to the fact that an attacker could tamper with the device in certain ways. Instances of this include; burning malicious firmware to the device, listening to the device and installing sensors to monitor the device. 

To protect against physical tampering, we decided to utilize the ESPs ‘sense of touch’. We did this by monitoring the capacitive variance on one of the pins on the ESP device. In the loop function we call a method we wrote called getTouch(). This reads the values of the capacitive variance on pin 32 of the ESP and then pushes these values to the array tValArray. Once this has a size of 20 it takes the average and if this is less than 20 it is inferred that the device has been touched and therefore sets the boolean tamperedBool to true. This boolean is then checked before the function joinmeOTAUpdate is called in the loop body and therefore an update will only occur if the device has never ‘felt a sense of touch’.  On the other hand, if when the average is taken it is higher than 20, then the array is cleared ready to be filled with new readings.

Once the tamperedBool has been set to true, it remains in this state permanently, which means you have to restart the device to reset it. To put this into context, this would allow someone to physically check the device for tampering before any more updates are installed. 


### Keeping a cached list of access points

One use of keeping a cached list of access points is that it removes the need to scan for networks whenever the /wifi page is called. This speeds up the get request the ESP makes to the web server when loading the page as the information is loaded from memory. 

To implement this, we wrote the function getWifiNetworks() which is called every 50 iterations within the loop body which equates to around every… seconds. This function scans for surrounding networks and stores these in two vectors; SSIDArray and RSSIArray. The next time the function is called these vectors are then cleared and repopulated. 
Then, when apListForm is called, instead of scanning for networks to populate the form the names and signals of the networks are loaded from memory. 






### Power consumption

The power consumption of the ESP32 varies depending on the running power mode it is in. There are various different configurable modes that have their own power saving capabilities that can help save power when you don't need all resources. 

[img]

##### Active mode - 160~260mA 
Also known as its normal mode, the active mode uses all of the chips features and keeps everything on at all times. 

***Active modules:***
* CPU
* Wi-Fi
* Bluetooth
* Radio
* RTC memory and peripherals
* ULP-Coprocessor

All of the active provisioning and OTA updates of the ESP will be carried out in active mode as it is the only power mode that supports WiFi functionality.

##### Modem sleep - 3~20mA
In modem sleep all features are active except for the most draining modules; Wifi, bluetooth and radio. An *association sleep pattern* is used to switch between active mode and modem sleep to keep the WiFi and bluetooth connections alive and stays connected to WiFi through a DTIM beacon mechanism. The AP transmits beacons periodically that the ESP picks up on at certain predetermined intervals to save power.

***Active modules***
* CPU
* ULP-Coprocessor
* RTC memory and peripherals

This mode is ideal for checking for updates and reading sensor values when the ESP is not utilising all of it's modules for provisioning and OTA updates. 

##### Hibernation mode - 2.5µA
In hibernation mode, the ULP-Coprocessor and RTC memory are both powered down. The only active components in this mode are the RTC timer and some RTC GPIOs which are responsible for waking the chip up from hibernation. 

If there is no connection to the web server, or the user fails to enter the network credentials on the config portal (timeout), then there is no need for the ESP to be running any modules at all until a reset is established. Thus, entering the ESP into hibernation mode during this period would be appropriate for minimal power consumption.



