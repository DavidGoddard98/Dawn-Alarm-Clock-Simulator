Dawn Alarm Clock Documentation
===

For our project we decided to implement a Dawn simulator alarm clock. Simply put, it has all of the functionality of an alarm clock with a few bonus features. Some of those features worth noting are; 

- LEDS that begin simulating dawn 5 minutes before the alarm (inc. 8 customizable colours)
- An IR sensor giving the option to snooze the alarm with movement
- Sophisticated power management to save battery life
- Extremely user friendly interface
- An alarm that can be set up to 7 days into the future
- Accurate time management
- Landscape mode...

See below an indepth examination detailing the implementation of the system.

## Overview of features
Before exploring the technicalities, presented below is a general overview of the Dawn Alarm Clock and it's features. 

### Menu
------
<br>
<div align = "center">
  <img src="images/menu_sketch.png" width="500"/>
</div>
<br>

1. **Page title**

2. **Menu item** – Selecting a menu item will direct the user to that page.

3. **Arrow icon** – Selecting a menu arrow icon will also direct the user to that page.

### Home Display
------
<br>
<div align = "center">
  <img src="images/home_sketch2.png" width="500"/>
</div>
<br>

1. **Greeting message** – A message depending on what time of day it currently is will be displayed at the top of the screen. There are four possible greetings:
    - Good morning (6am to 11.59am)
    - Good afternoon (12pm to 4.59pm) 
    - Good afternoon (5pm to 7:59pm)
    - Good night (8pm to 5:59am)<br><br>

2. **Digital time display** – This area will display the current time in HH:MM:SS, updated every second.

3. **Date display** – The bottom corner will display the current date and day of the week, updated every 24 hours.

4. **Time to alarm** – The time to alarm will be displayed under the digital time if an alarm has been set. If the time to alarm is greater than a minute it will be formatted in H:M, otherwise a countdown in seconds from a minute will commence. If no alarm has been set, or an alarm has passed, a 'No alarm set' message is shown. 

### Setting an Alarm
------
<br>
<div align = "center">
  <img src="images/home_sketch4.png" width="500"/>
</div>
<br>

1. **Page title**
2. **Menu icon** – Selecting this icon will direct the user to the Menu page.

3. **Alarm hours** – Displays alarm hour time.

4. **Alarm minutes** – Displays alarm minute time.

5. **Increment/decrement alarm hour** – Selecting the triangle above the hour time will increment the alarm hour, and selecting the triangle below the hour time will decrement the alarm hour.

6. **Increment/decrement alarm minute** – Selecting the triangle above the minute time will increment the alarm minute, and selecting the triangle below the minute time will decrement the alarm minute.

7. **Alarm day** – Displays the day of the alarm.

8. **Increment/decrement alarm day** – Selecting the triangle to the right of the alarm day will increment to the next day of the week, and selecting the triangle to the left of the alarm day will decrement to the previous day of the week.

9. **Set alarm** – Selecting the 'Set' button will create an alarm based on the time inputted by the user. If the alarm is set 'before' the current time, it will assume it is meant for the future (for instance - given the example in the diagram, setting the alarm for Thursday at 13:32 will create an alarm for 144 hours time).

### Setting Dawn Colour
------
<br>
<div align = "center">
  <img src="images/dawn_sketch.png" width="500"/>
</div>
<br>

1. **Page title**
2. **Menu icon** – Selecting this icon will direct the user to the Menu page.

3. **Colour palette** – This area will display a range of colours to choose from - each box will contain a different colour that the user can pick for the dawn simulation.

### Buttons 
------
<br>
<div align = "center">
  <img src="images/button_sketch.png" width="500"/>
</div>
<br>

1. **Snooze** – This button can be pressed during the alarm to snooze it for 5 minutes (similar functionality to the IR sensor).

2. **Sleep** – This button can be pressed to put the unPhone into deep sleep mode and save power.

3. **Multifunctional** – This button has two purposes; It can be pressed during the alarm to stop it completely, and it can wake the unPhone from a deep sleep.

## Technical Documentation
The following section will elaborate more on the technical features of the Dawn Alarm Clock, as well as describing how challenging problems discovered during development were overcome.

### NeoPixel troubleshooting & Dawn Simulator 
------
Immediately after setting up the NeoPixel libraries and testing the functionality, we came across a subtle but evident ghosting problem with the LEDs. Despite explicitly setting all the pixels to OFF (equivalent to setting their RGB values to 0,0,0), there would be times that seemingly arbitrary pixels would appear in random colours. Cutting the power being supplied from the battery entirely `unPhone::setShipping(true)` would not change the outcome either. 

The NeoPixel LED module was souldered onto 2.54mm breakway male-female header connectors over the unPhone expander which allowed for a semi-permanent installation. This proved to be a practical design when attempting to fix the ghosting issue of the pixels, as perhaps it was due to the `NEOPIXEL_PORT` pin that was initially defined for the LEDs. However, disabling the physical pin on the Adafruit NeoPixel and defining a new pin did not solve the issue.

Nevertheless, the main concern was with the first pixel that was consistently not behaving as intended that we did find a solution for. We discovered that explicitly setting the first pixel to OFF followed by a short delay would prevent it from ghosting. Moreover, setting a delay between the state of the pixels and displaying them appeared to ameliorate the ghosting issue as a whole:   

```c
void pixelsOff() {
  //set all values to 0
  for	( int i = 0 ; i < NR_LED ; i ++ )	{
    np_set_pixel_rgbw(&px, i , 0, 0, 0, 0);
  }
  delay(1000);
  np_show(&px, NEOPIXEL_RMT_CHANNEL);

  //let pixels settle
  //re set 1st pixel (often glitches and stays on)
  np_set_pixel_rgbw(&px, 0 , 0, 0, 0, 0);
  delay(100);
  np_show(&px, NEOPIXEL_RMT_CHANNEL);
}
```

All of the colours used on the Arduino TFT touchscreen are defined in the `Adafruit_HX8357.h` file. In addition to the default colours provided, three more were defined for the customisation of dawn; pink, purple and orange. These colours, however, must be defined in RGB565 format - so the following were appended to the header file:
```c
#define HX8357_PINK 0xF815
#define HX8357_PURPLE 0x91F
#define HX8357_ORANGE 0xFC40
```
The dawn is set to come on exactly 4 minutes before the alarm, with proportionate brightness increments ranging from 0 (min brightness) to 255 (max brightness). This is achieved by increasing the brightness by 1/255 every 240/255 seconds (~0.94). Once a colour has been chosen from the dawn page, a method from the `main.cpp` is called to then set the dawn colour:
```c
void setDawnColour(uint16_t col) {
  if (col == HX8357_BLUE) {
    rgb = make_tuple(0,0,255); // tuple saved in RTC memory for later retrieval
  }
  ...
```
In addition to the brightness, the colour must also remain consistent by keeping the RGB ratios the same, which can be done by multiplying them by the same magnitute of brightness:
```c
void fadePixels() {
  pixBr += 0.003921569f; // 1/255
  for	( int j = 0 ; j < NR_LED ; j ++ )	{ // retrieve RGB values from saved tuple 
    np_set_pixel_rgbw(&px, j , get<0>(rgb)*pixBr, get<1>(rgb)*pixBr, get<2>(rgb)*pixBr, pixBr*255);
  }
  np_show(&px, NEOPIXEL_RMT_CHANNEL); // display on LEDs
}
```
The dawn is only active during the 4 minutes prior to the alarm, which means that any snooze executed during that time will temporarily stop the LEDs (as snoozing will add 5 minutes to the alarm time).

### Power Management

With any IOT device, efficient power management is a critical characteristic to manage. While it is true that many projects such as the air quality sensor need to be efficient enough to survive weeks without a charge, the context of an alarm clock means that this is not a requirement with our project. Despite this, we decided to make the device as efficient as possible so that it doesnt have to remain on charge. 

##### Deep sleeps
The best way of improving efficiency is putting the device into a deep sleep whenever possible. This is because if left in active mode the ESP requires 160-240mA current to operate - with a deep sleep this can be reduced to as little as 10uA. We decided that our alarm clock only needed to be active when the user requested it to be on, or for the 4 minutes between the dawn simulator starting and the actual alarm (plus around 20 seconds so that it can start the fade in). Because of this we implemented a feature to put the the device to sleep after 30 seconds of inactivity (i.e 30 seconds since the last registered touch), or when the used pressed button 2. In either of these cases the device can then be woken up with button 3. 

If an alarm is set however, the ESP will automatically wake itself up 20 seconds before the dawn simulator is about to begin. The ESP will then remain active up until the alarm goes off at which point it depends on user interaction;
1) If the alarm is cancelled then the device will sleep until manually woken up
2) If the alarm is snoozed (5 minutes) then the ESP will sleep for 40 seconds then wake itself up and begin the dawn again.

##### Peripherals
To improve efficiency further the ESP is disconnected from its WiFi connection and access point after the internal clock is synronized with the NTP server.

Sparkfun Open PIR module - 

Neopixel featherwing - 

##### Shipping mode
If the power switch is used and the ESP is not connected by USB, then the device is put into shipping mode. This tells the BM to stop supplying power and therefore means 0mA are used (the most power efficient option). This does however mean that when the device is switched back on, all the memory has been wiped and therefore any desired alarms must be reset.


### Time Management

Any alarm clock relies wholeheatedly on accurate time keeping, without which, its uses become entirely redundant. For this reason, implementing strictly correct time mangement was of upmost priority during this project.

Early implementations involved setting the time manually and then using the internal RTC on the ESP (in this case a 150kHz oscillator) to keep track of it. It managed to do a reasonable job, yet due to the fact that all clocks drift, it wasn't long before the time shown was incorrect. After some testing we recorded the results below;

| Time Start (H:M:S) | Time End | Time recorded | Length  | Drift (Seconds) |
|--------------------|----------|---------------|---------|-----------------|
| 17:42:00           | 18:42:00 | 18:43:30      | 1 hour  | 90s             |
| 16:40:01           | 17:40:01 | 16:41:26      | 1 hour  | 85s             |
| 14:30:30           | 15:30:30 | 15:31:58      | 1 hour  | 88s             |
| 12:24:35           | 14:24:35 | 14:27:44      | 2 hours | 189s            |
| 15:34:02           | 16:34:02 | 16:38:40      | 3 hours | 278s             |
*Avg drift p/hour = 27.7s*

Although this early implementation provided a way of tracking the time, it was clearly not an approriate solution by itself to be used for telling the time. For one, there was no way of resetting the time except from manually burning new firmware. This meant the drift would continue to make the time more and more inaccurate. Also, if the ESP was reset or the power was lost, the memory allocated to holding the time would be wiped. These problems prompted us to implement a function (fetchTime()) which would semi-frequently automatically syncronize the time to an atomic clock using a Network Time Protocol (NTP). This solution would ensure that an accurate time could be frequently obtained, avoiding the issue of an inaccurate clock. Also, if the device was ever reset, then the time could be reset automatically.

To do this, we firstly needed to provision the ESP so that we could connect it to a network in the first place. After this we would need the ESP to send a request packet to a NTP server, which in turn, would respond with a time stamp packet. This information could then be used to set the internal time of the ESP with pinpoint precision. See code below;


```c++
void fetchTime() {
  //provisioning...
  joinmeManageWiFi(apSSID.c_str(), apPassword.c_str());

  //GET current time and print to serial line
  while( year < 118) { // if time returned is a year <2018 then incorrect so fetch again
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer); //gets current time
    delay(1000);
    time(&time_now);
    struct tm yearCheck; //store time in tm struct
    yearCheck = *localtime(&time_now);
    //stores year - (if < 2018 then time was not retrievied correctly)
    //default is 1970...
    year = yearCheck.tm_year;
  }

  //disconnect WiFi/stop AP as it's no longer needed (SAVE BATTERY)
  WiFi.disconnect(true);
}
```
*The while loop ensures the correct time is obtained, as during testing we noticed it took a few attempts to recieve the packet.*

A statement must be made about the frequency of these syncronizations - too many and the drain on battery power due to connectivity would introduce a new issue. We decided that this function would be called every time the device is initially booted (so also after every reset/power outage), and in the instance these events do not occur, every two hours. This limited the inaccuracy of our time to.. 27.7(avg. drift time after 1 hour) x (2) = 55.4s.

Due to our decisions with power management (see power management below), the ESP spends the majourity of its time in a deep sleep. Unfourtunately, this presented us with a further issue - keeping track of the time during deep sleeps. Clearly an NTP server could be used on every boot, yet, as mentioned, this would use unnecessary amounts of power. The solution to this isuse was to;
##### Before deep sleep
1) Measure # ticks on RTC 
2) Measure epoch time
##### Once woken up 
3) Calculate number of ticks during sleep
4) Convert to seconds
5) Increment epoch time by this amount

*Note: Values from points 1/2 are stored in the RTC memory using RTC_DATA_ATTR and then loaded into RTC fast memory. This enables the information to be saved during deep sleeps.*

See the implementation below;
```c++
void updateTime() {
  //timeNow = RTC clock now - offset ...(essentially RTC clock now)
  //offset = duration of setup() during initial boot
  timeNow = rtc_time_slowclk_to_us(rtc_time_get(), esp_clk_slowclk_cal_get()) - offset_time; //this offset is from fetchTime() method
  //timeDiff = timeESP has been asleep for
  //sleepTime is recorded just before ESP goes to sleep - see inActiveSleep()
  timeDiff = timeNow - sleepTime;

  //Must convert this into seconds to add to clock
  //#secs
  int seconds = floor((timeDiff / 1000000));
  //#milis
  int milis = floor(timeDiff % 1000000);

  //Deal with offset.. with a 30 seconds drift after an hour..
  //30/3600 = 0.0083. Drift of that length p/sec
  seconds = seconds * 0.9917; //0.9917 = 1-0.0083

  if (milis+old_milis > 1000) {
    //if milis more than 1000 add second to time
    seconds += 1;
    //make up the difference to save the rest of the milis which didnt make the 1 sec
    old_milis = (old_milis + milis) -1000 ;
  } else {
    old_milis += milis;
  }

  //Finally....
  //add the time ESP has been asleep to clock
  time_now = time_t(time_now) + seconds;
  timeinfo = localtime (&time_now);
}
```
Note: even though the inaccuracy due to drift was slight we implemented an offset to make it less significant. 

```c++
//Deal with offset.. with a 30 seconds drift after an hour..
//30/3600 = 0.0083. Drift of that length p/sec
seconds = seconds * 0.9917; //0.9917 = 1-0.0083
```

New testing to show time keeping improvement;

| Time Start (H:M:S) | Time End | Time recorded | Length      | Drift (Seconds) |
|--------------------|----------|---------------|-------------|-----------------|
| 9:04:00            | 10:04:00 | 10:04:05      | 1 hour      | 5s              |
| 10:10:00           | 11:10:00 | 11:11:04      | 1 hour      | 4s              |
| 12:05:30           | 13:05:30 | 13:05:37      | 1 hour      | 7s              |
| 13:10:02           | 15:09:30 | 15:09:42      | Just<2hours | 12s             |
*Avg drift p/hour: 5.3s*



### Updating UI Elements 
------
The user interface implementation as a whole proved to be a lot more technical than first anticipated, especially for changing the apperance of elements on the same screen. Initially there was the idea of refreshing the entire screen each time something changed, however this approach exhibited a lot of constant flickering especially on pages that have a lot of elements or high frequency of changes such as the Home Display or Set Alarm. Instead, we devised a much more sophisticated method that involved placing filled-in rectangles over specfic areas just before they require updating:
```c
void HomeUIElement::drawTime() {
  if (sc != timeinfo->tm_sec) // clear sec if changed
    clearSec();
...
    sc = timeinfo->tm_sec; // update temp for checking previous/current value 
}
void HomeUIElement::clearSec() {
  m_tft->fillRect(  360,   90,  100,  75, BLACK);
}
```
<br>
<div align = "center">
  <img src="images/update_sketch.png" width="1000"/>
</div>
<br>

The colour of the rectangles contrast with the background in this case for illustration purposes - they would normally be the same colour to produce a seamless overlap. Each element has its own *clear* method that writes over its previous state:

<br>
<div align = "center">
  <img src="images/element_sketch.png" width="500"/>
</div>
<br>

1. **clearGreeting()** – Updates 4 times a day
2. **clearSec()** – Updates ~1s
3. **clearMin()** – Updates ~1m
4. **clearHour()** – Updates ~1h
5. **flashDots()** – Updates ~1s
6. **clearAlarm()** – Updates ~1m or ~1s depending on time to alarm
7. **clearDate()** – Updates ~24h

Another issue we discovered at this point was being able to `handletouch()` on the Home Display. This was not a challenge for other pages because they didn't need to display elements such as current time or date that update continuously, while still being able to register touches in the same dedicated process. To overcome this we needed to essentially run concurrent processes that dealt with the UI elements and touch separately; so the `draw()` method was included in the `runEachTurn()` method in Home Display. 


### Orientation & Touch Management  
------
##### Orientation
One of the first things that sprung to mind when designing the user interface was changing the orientation from portrait to landscape, as a longer horzontal axis would be ideal for the type of information the Dawn Alarm Clock would be displaying. Browsing through the `Adafruit_HX8357.cpp` library we discovered 4 different `setRotation()` methods for each orientation; 0 (portrait), 1 (right-landscape), 2 (upside-down portrait), 3 (left-landscape). However, when attempting to change the orientation to either landscapes (1 or 3) the display appeared to be mirrored. Further digging into the library we discovered `#define MADCTL_MV  0x20` which is commented as *Reverse mode*. This definition was also included in the rotation that we wanted:
```c
void Adafruit_HX8357::setRotation(uint8_t m) {
  rotation = m & 3; // can't be higher than 3
  switch(rotation) {
    case(0):
     ...
    case(3):
      m = MADCTL_MX | MADCTL_MV | MADCTL_RGB;
      _width  = HX8357_TFTHEIGHT;
      _height = HX8357_TFTWIDTH;
      break;
  }
  sendCommand(HX8357_MADCTL, &m, 1);
}
``` 
Clearly, this had something to do with the output we were experiencing. We then found a [TFT HX8357](https://github.com/Bodmer/TFT_HX8357/blob/master/TFT_HX8357.cpp) library that had similar `setRotation()` methods to the ones in the unPhone library: 
```c
void TFT_HX8357::setRotation(uint8_t m)
{
  writecommand(HX8357_MADCTL);
  rotation = m % 8;
  switch (rotation) {
   case 0: // Portrait
     writedata(MADCTL_BGR | MADCTL_MX);
     _width  = HX8357_TFTWIDTH;
     _height = HX8357_TFTHEIGHT;
     break;
   case 1: // Landscape (Portrait + 90)
     writedata(MADCTL_BGR | MADCTL_MV);
     _width  = HX8357_TFTHEIGHT;
     _height = HX8357_TFTWIDTH;
     break;
   case 2: // Inverter portrait
     writedata( MADCTL_BGR | MADCTL_MY);
     _width  = HX8357_TFTWIDTH;
     _height = HX8357_TFTHEIGHT;
    break;
   case 3: // Inverted landscape
     writedata(MADCTL_BGR | MADCTL_MV | MADCTL_MX | MADCTL_MY);
     _width  = HX8357_TFTHEIGHT;
     _height = HX8357_TFTWIDTH;
     break;
   case 4: // Portrait
     writedata(MADCTL_BGR | MADCTL_MX | MADCTL_MY);
     _width  = HX8357_TFTWIDTH;
     _height = HX8357_TFTHEIGHT;
     break;
   case 5: // Landscape (Portrait + 90)
     writedata(MADCTL_BGR | MADCTL_MV | MADCTL_MX);
     _width  = HX8357_TFTHEIGHT;
     _height = HX8357_TFTWIDTH;
     break;
   case 6: // Inverter portrait
     writedata( MADCTL_BGR);
     _width  = HX8357_TFTWIDTH;
     _height = HX8357_TFTHEIGHT;
     break;
   case 7: // Inverted landscape
     writedata(MADCTL_BGR | MADCTL_MV | MADCTL_MY);
     _width  = HX8357_TFTHEIGHT;
     _height = HX8357_TFTWIDTH;
     break;
  }
}
 ```
`case 1: // Landscape (Portrait + 90)` then became our new `setRotation(3)` in the `Adafruit_HX8357.cpp` library which produced the desired unmirrored landscape orientation:
```c
void Adafruit_HX8357::setRotation(uint8_t m) {
  rotation = m & 3; // can't be higher than 3
  switch(rotation) {
    case 0:
    ...
    case 3:
      m       = MADCTL_BGR | MADCTL_MV;
      _width  = HX8357_TFTHEIGHT;
      _height = HX8357_TFTWIDTH;
      break;
  }
  sendCommand(HX8357_MADCTL, &m, 1);
}
```
##### Mapping
Evidently, changing the orientaion did not come with a free lunch - the TFT screen now had to be re-mapped to correctly register points on the touchscreen. The previous configuration meant that the top right of the screen was the origin and had the x-axis running down the right side of the screen and the y-axis along the top:

<br>
<div align = "center">
  <img src="images/rotation_sketch.png" width="500"/>
</div>
<br>

The correct configuration after rotating +90° to landscape orientation would need to be mapped like the following:

<br>
<div align = "center">
  <img src="images/rotation_sketch2.png" width="500"/>
</div>
<br>

The `map()` syntax is as follows: **map(value, fromLow, fromHigh, toLow, toHigh)**. It re-maps a number from one range to another; that is, a value **fromLow** would get mapped **toLow** and a value from **fromHigh** to **toHigh** etc. The parameters are:
* **value** – the number to map
* **fromLow** – the lower bound of the value's current range
* **fromHigh** – the upper bound of the value's current range 
* **toLow** – the lower bound of the value's target range 
* **toHigh** – the upper bound of the value's target range 

So, we need to map the raw touch coordinates (**fromLow** | **fromHigh**) to the new screen coordinates (**toLow** | **toHigh**). Additionally, a **temp p.x** value will be needed in the mapping of **p.y** so that **p.y** updates correctly, otherwise only the first touch will be registered correctly and any subsequent touches will assume the initial **x** value:

```c
// raw touch calibration data 
#define TS_MINX 3800
#define TS_MAXX 100
#define TS_MINY 100
#define TS_MAXY 3750
```

```c
void UIController::handleTouch() {
  // adjust mapping for landscape orientation
  // unPhone width & height --> 320 X 480
  int16_t nTmpX = p.x; // temp p.x so that p.y updates
  p.x = map(p.y, unPhone::TS_MINY, unPhone::TS_MAXY, 0, unPhone::tftp->width());
  p.y = map(nTmpX, unPhone::TS_MINX, unPhone::TS_MAXX, 0, unPhone::tftp->height());
  if(m_element->handleTouch(p.x, p.y)) {
    if(++modeChangeRequests >= MODE_CHANGE_TOUCHES) {
      changeMode();
      modeChangeRequests = 0;
    }
  }
}
```
This will position the origin at the top left of the screen and have the x-axis running along the top and y-axis running down the side. 

##### Getting Touch Point
Something that became very apparent when interacting with elements on the screen was the delayed response between registering touches. For instance, touching anywhere on the Home Display would bring up the Menu, but then selecting a menu item would not normally direct you to that page because it would register the previous point that was touched on the Home Display as the one touched in the Menu. In other words, it was executing touches in a 'queue' that did not correspond correctly to the elements on the current page. This erroneous behaviour was due to not reading all the data in the buffer and resetting all ints when the buffer was empty:
```c
TS_Point Adafruit_STMPE610::getPoint() {
  uint16_t x, y;
  uint8_t z;
  while (!bufferEmpty()) {
    readData(&x, &y, &z);
  }
  if (bufferEmpty())
    writeRegister8(STMPE_INT_STA, 0xFF); // reset all ints

  return TS_Point(x, y, z);
}
```
Furthermore, we also noticed that there would occasionally be very peculiar readings at point x ~ 16300, y ~ -12500, z ~ 25. A simple `if (p.x > 10000) {return false;}` included in the `gotTouch()` method was enough to omit this reading. 

Before implementing the buffer fix, navigation was impossible; combining these two fixes greatly increased touch accuracy and responsiveness. A very effective debugging tool that was used to test the points being registered was included in the `handleTouch()` method that displayed a tiny green box each time the screen was touched:

```c
unPhone::tftp->fillRect(p.x-1,p.y-1,2,2,HX835 7_GREEN); // DEBUG touch feedback
```

##### Edited unPhone Library
In order to implment the above changes to orientation and touch buffer amendments were made in the unPhone project folder, specifically the `Adafruit_HX8357.cpp` and `Adafruit_STMPE610.cpp` libraries which are not part of `MyProjectThing`. Therefore, the amended versions of these libraries have been imported in the `lib` directory and referenced in the `component.mk` file: 
```c
COM3505_2019-STUDENT_LIB=../lib 
# library sources
BIGDEMOIDF_LIBS := $(UNPHONE_SRC_DIR) \
  $(COM3505_2019-STUDENT_LIB)/Adafruit_HX8357_Library \
  $(COM3505_2019-STUDENT_LIB)/Adafruit_STMPE610 \
```

### Future Improvements
------
Had we had more time for the project, there were a number of ideas and features that could have made their way into the Dawn Alarm Clock;
* **Personal greeting on Home Display page** – The idea behind this was to allow the user to input their name and have it included in the greeting, for example: ***Good afternoon, Hamish***. One of the main reasons why this was not included was due to the complexities arising from text-based user input such as designing a keyboard or rotating through letters of the alphabet (similar mechanic to setting the alarm). We even considered doing it through phone (similar to provisioning) but again this would have added unecessary difficulties. 
* **Showing weather at current location on Home Display page** – Unfortunately there does not exist a universal weather library like there does for time. We would need to look into weather API's and potentially GPS which would require a lot of time and dedicated work.
* **Customisable dawn time** – Perhaps the most reasonable improvement that could have been made had we had a bit more time. Currently dawn is set to come on 4 minutes before the alarm and cannot be changed. 
* **Set alarm longer than 7 days into the future** – One of the most time consuming features of the project was being able to set an alarm ***up to*** 7 days into the future, from just 24 hours into the future. Implementing this feature would not have come without its unforseen technicalities.
* **Recurring alarms (more than 1 alarm)** – In addition to adapting the core functionality in many areas of code, we would also need to consider changing many UI elements to accomodate more active alarms.   
