Dawn Alarm Clock Documentation
===

For our project we decided to implement a Dawn simulator alarm clock. Simply put, it has all of the functionality of an alarm clock with a few bonus features. Some of those features worth noting are; 

- LEDS that begin simulating dawn 5 minutes before the alarm (inc. 8 customizable colours)
- An IR sensor giving the option to snooze the alarm with movement
- Sophisticated power management to save battery life
- Extremely user friendly interface
- An alarm that can be set up to 7 days into the future
- Accurate time management
- Landscape mode...

See below an indepth examination detailing the implementation of the system.

## Overview of features
Before exploring the technicalities, presented below is a general overview of the Dawn Alarm Clock and it's features. Sketches have been included to help illustrate initial concepts and ideas. 

### Menu
------
<br>
<div align = "center">
  <img src="images/menu_sketch.png" width="500"/>
</div>
<br>

1. **Page title**

2. **Menu item** – Selecting a menu item will direct the user to that page.

3. **Arrow icon** – Selecting a menu arrow icon will also direct the user to that page.

### Home Display
------
<br>
<div align = "center">
  <img src="images/home_sketch2.png" width="500"/>
</div>
<br>

1. **Greeting message** – A message depending on what time of day it currently is will be displayed at the top of the screen. There are four possible greetings:
    - Good morning (6am to 11.59am)
    - Good afternoon (12pm to 4.59pm) 
    - Good afternoon (5pm to 7:59pm)
    - Good night (8pm to 5:59am)<br><br>

2. **Digital time display** – This area will display the current time in HH:MM:SS, updated every second.

3. **Date display** – The bottom corner will display the current date and day of the week, updated every 24 hours.

4. **Time to alarm** – The time to alarm will be displayed under the digital time if an alarm has been set. If the time to alarm is greater than a minute it will be formatted in H:M, otherwise a countdown in seconds from a minute will commence. If no alarm has been set, or an alarm has passed, a 'No alarm set' message is shown. 

### Setting an Alarm
------
<br>
<div align = "center">
  <img src="images/home_sketch4.png" width="500"/>
</div>
<br>

1. **Page title**
2. **Menu icon** – Selecting this icon will direct the user to the Menu page.

3. **Alarm hours** – Displays alarm hour time.

4. **Alarm minutes** – Displays alarm minute time.

5. **Increment/decrement alarm hour** – Selecting the triangle above the hour time will increment the alarm hour, and selecting the triangle below the hour time will decrement the alarm hour.

6. **Increment/decrement alarm minute** – Selecting the triangle above the minute time will increment the alarm minute, and selecting the triangle below the minute time will decrement the alarm minute.

7. **Alarm day** – Displays the day of the alarm.

8. **Increment/decrement alarm day** – Selecting the triangle to the right of the alarm day will increment to the next day of the week, and selecting the triangle to the left of the alarm day will decrement to the previous day of the week.

9. **Set alarm** – Selecting the 'Set' button will create an alarm based on the time inputted by the user. If the alarm is set 'before' the current time, it will assume it is meant for the future (for instance - given the example in the diagram, setting the alarm for Thursday at 13:32 will create an alarm for 144 hours time).

### Setting Dawn Colour
------
<br>
<div align = "center">
  <img src="images/dawn_sketch.png" width="500"/>
</div>
<br>

1. **Page title**
2. **Menu icon** – Selecting this icon will direct the user to the Menu page.

3. **Colour palette** – This area will display a range of colours to choose from - each box will contain a different colour that the user can pick for the dawn simulation.

### Buttons 
------
<br>
<div align = "center">
  <img src="images/button_sketch.png" width="500"/>
</div>
<br>

1. **Snooze** – This button can be pressed during the alarm to snooze it for 5 minutes (similar functionality to the IR sensor).

2. **Sleep** – This button can be pressed to put the unPhone into deep sleep mode and save power.

3. **Multifunctional** – This button has two purposes; It can be pressed during the alarm to stop it completely, and it can wake the unPhone from a deep sleep.

### LEDs & IR Sensor 
------
<br>
<div align = "center">
  <img src="images/back_sketch.png" width="500"/>
</div>
<br>

1. **IR Sensor** – The back of the unPhone has an IR sensor attached to it that will detect any motion from around 2 meters away. It can be used as a snoozing mechanism that will delay the alarm for 5 minutes once it has been activated.

2. **LEDs** – In addition to the IR Sensor, the rear of the unPhone also has powerful LEDs that will gradually increase in brightness in the colour set from the dawn page, 5 minutes before the alarm goes off. 


### Time Management

Any alarm clock relies wholeheatedly on accurate time keeping, without which, its uses become entirely redundant. For this reason, implementing strictly correct time mangement was of upmost priority during this project.

One of the difficulties with using the ESP32 to keep accurate track of time is that the internal RTC quickly drifts leaving inaccurate measurements. Under testing we noted an average drift of about XXX every hour (This was added to the time I.E the RTC ran faster). An easy fix was to incorperate a marginal offset to be deducted from every second counted. 
The table below shows four experiments: two measuring the RTC time vs real time without the offset implemented and two with it implemented. 

XXXXXXXXXXXXXXXXXXXXXXXXXXX

While this fix worked, it was clear for a magnitute of reasons that it was not a sustainable solution. For instance, if the ESP was reset or the power was lost, this memory would be wiped. Moreover even with the offset, the time would drift. These problems prompted us to implement a function (fetchTime()) which would semi-frequently syncronize the time using a Network Time Protocol (NTP). 

To do this, we firstly needed to provision the ESP so that we could connect it to a network in the first place. After this we would need the ESP to send a request packet to a NTP server, which in turn, would respond with a time stamp packet. This information could then be used to set the internal time of the ESP with pinpoint precision. See code below;


```c++
void fetchTime() {
  //provisioning...
  joinmeManageWiFi(apSSID.c_str(), apPassword.c_str());

  //GET current time and print to serial line
  while( year < 118) { // if time returned is a year <2018 then incorrect so fetch again
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer); //gets current time
    delay(1000);
    time(&time_now);
    struct tm yearCheck; //store time in tm struct
    yearCheck = *localtime(&time_now);
    //stores year - (if < 2018 then time was not retrievied correctly)
    //default is 1970...
    year = yearCheck.tm_year;
  }

  //disconnect WiFi/stop AP as it's no longer needed (SAVE BATTERY)
  WiFi.disconnect(true);
}
```
The while loop ensures the correct time is obtained, as during testing we noticed the time would often be set incorrectly. 

A statement must be made about the frequency of these syncronizations - too many and the drain on battery power due to connectivity would introduce a new issue. We decided that this function would be called every time the device is initially booted (so also after every reset/power outage), and in the instance these events do not occur, every two hours. Therefore the limit to the inaccuracy of our time is totalled at.. (drift time after 1 hour) x (2). A result we are considerably happy with. 

With the frequency implemented above, we quickly ran into another issue; how to track the time during the deep sleeps that will inevitably occur in the two hour period? As is, the ESP refuses to keep track of time during a deep sleep. Clearly an NTP server could be used on every boot, yet, as mentioned, this would require unneccessary battery drainage. The solution to this isuse was to record the duration of any sleep and add this onto the time the ESP had counted to before sleep - contrary to what was said before, this is possible as an internal RTC clock remains in this sleep period. 
```c++
void updateTime() {
  //timeNow = RTC clock now - offset ...(essentially RTC clock now)
  //offset = duration of setup() during initial boot
  timeNow = rtc_time_slowclk_to_us(rtc_time_get(), esp_clk_slowclk_cal_get()) - offset_time; //this offset is from fetchTime() method
  //timeDiff = timeESP has been asleep for
  //sleepTime is recorded just before ESP goes to sleep - see inActiveSleep()
  timeDiff = timeNow - sleepTime;

  //Must convert this into seconds to add to clock
  //#secs
  int seconds = floor((timeDiff / 1000000));
  //#milis
  int milis = floor(timeDiff % 1000000);

  if (milis+old_milis > 1000) {
    //if milis more than 1000 add second to time
    seconds += 1;
    //make up the difference to save the rest of the milis which didnt make the 1 sec
    old_milis = (old_milis + milis) -1000 ;
  } else {
    old_milis += milis;
  }

  //Finally....
  //add the time ESP has been asleep to clock
  time_now = time_t(time_now) + seconds;
  timeinfo = localtime (&time_now);
}
```